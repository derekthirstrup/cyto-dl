# Example configuration for efficient random timelapse sampling
# Supports nd2, czi, ome-zarr, tif stacks, and other bioio formats
# Works with local and S3/cloud storage paths

_target_: cyto_dl.datamodules.random_timelapse_datamodule.RandomTimelapseDatamodule

# Path to CSV file with metadata (can be local or S3 path like s3://bucket/data.csv)
# CSV should have columns: path, channel, split (train/val/test)
# Optional columns: scene, resolution, start, stop
path: /path/to/your/metadata.csv

# Column names in CSV
img_path_column: path  # Column with file paths (supports S3, local, etc.)
channel_column: channel  # Column with channel indices (e.g., "0" or "0,1,2")
split_column: split  # Column with split labels (train/val/test)

# Timepoint sampling configuration
num_timepoints: 1  # Number of timepoints to sample per file per batch
timepoint_sampling: random  # Options: 'random', 'sequential', 'uniform'
# 'random': Randomly sample num_timepoints frames (good for diverse training data)
# 'sequential': Sample consecutive frames from random start (good for temporal models)
# 'uniform': Sample evenly spaced frames (good for full timelapse coverage)

# Optional: specify timepoint range columns in CSV
time_start_column: start  # Column with starting frame (default: 0)
time_stop_column: stop  # Column with ending frame (default: all frames)

# Image properties
spatial_dims: 3  # 2 for YX, 3 for ZYX
scene_column: scene  # Column with scene index (optional, defaults to first scene)
resolution_column: resolution  # Column with resolution level (optional, defaults to 0)

# Optional: extra columns to include in sample dictionary
extra_columns:
  - cell_id
  - treatment
  - replicate

# Optional: control number of samples per epoch (useful for oversampling/undersampling)
# If not specified, uses length of dataframe
samples_per_epoch:
  train: 1000  # Sample 1000 batches per training epoch
  val: 100  # Sample 100 batches per validation epoch

# Random seed for reproducibility
seed: 42

# DataLoader settings
num_workers: 4
batch_size: 8
pin_memory: True
persistent_workers: True
shuffle: True  # Only applied to train split

# Transforms for each split
transforms:
  train:
    _target_: monai.transforms.Compose
    transforms:
      # Load image using BioIO (supports all formats)
      - _target_: cyto_dl.image.io.bioio_loader.BioIOImageLoaderd
        path_key: original_path
        out_key: raw
        dask_load: True  # Use Dask for lazy loading
        dtype: numpy.float32

      # Add channel dimension if needed
      - _target_: monai.transforms.EnsureChannelFirstd
        keys: raw
        channel_dim: "no_channel"

      # Data augmentation
      - _target_: monai.transforms.RandSpatialCropd
        keys: raw
        roi_size: [64, 64, 64]  # Adjust based on spatial_dims
        random_size: False

      - _target_: monai.transforms.RandFlipd
        keys: raw
        prob: 0.5
        spatial_axis: [0, 1, 2]

      - _target_: monai.transforms.RandRotate90d
        keys: raw
        prob: 0.5
        spatial_axes: [0, 1]

      # Normalize
      - _target_: monai.transforms.NormalizeIntensityd
        keys: raw
        channel_wise: True

      # Convert to tensor
      - _target_: monai.transforms.ToTensord
        keys: raw

  val:
    _target_: monai.transforms.Compose
    transforms:
      - _target_: cyto_dl.image.io.bioio_loader.BioIOImageLoaderd
        path_key: original_path
        out_key: raw
        dask_load: True
        dtype: numpy.float32

      - _target_: monai.transforms.EnsureChannelFirstd
        keys: raw
        channel_dim: "no_channel"

      - _target_: monai.transforms.NormalizeIntensityd
        keys: raw
        channel_wise: True

      - _target_: monai.transforms.ToTensord
        keys: raw

  test:
    _target_: monai.transforms.Compose
    transforms:
      - _target_: cyto_dl.image.io.bioio_loader.BioIOImageLoaderd
        path_key: original_path
        out_key: raw
        dask_load: True
        dtype: numpy.float32

      - _target_: monai.transforms.EnsureChannelFirstd
        keys: raw
        channel_dim: "no_channel"

      - _target_: monai.transforms.NormalizeIntensityd
        keys: raw
        channel_wise: True

      - _target_: monai.transforms.ToTensord
        keys: raw
